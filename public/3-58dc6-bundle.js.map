{"version":3,"sources":["webpack:///./node_modules/topojson-client/src/identity.js","webpack:///./node_modules/topojson-client/src/transform.js","webpack:///./node_modules/topojson-client/src/reverse.js","webpack:///./node_modules/topojson-client/src/feature.js","webpack:///./node_modules/topojson-client/src/stitch.js","webpack:///./node_modules/topojson-client/src/mesh.js","webpack:///./node_modules/topojson-client/src/bisect.js","webpack:///./node_modules/topojson-server/src/hash/point-hash.js","webpack:///./node_modules/topojson-simplify/src/spherical.js","webpack:///./node_modules/topojson/index.js"],"names":["x","transform","identity","x0","y0","kx","scale","ky","dx","translate","dy","input","i","j","n","length","output","Array","t","array","o","type","features","geometries","map","topology","id","bbox","properties","geometry","transformPoint","arcs","arc","points","pop","a","k","push","reverse","point","p","line","ring","polygon","coordinates","stitchedArcs","fragmentByStart","fragmentByEnd","fragments","emptyIndex","flush","f","start","end","forEach","g","e","p1","p0","dp","ends","fg","concat","unshift","gf","meshArcs","apply","this","arguments","object","filter","geom","geomsByArc","extract0","extract1","extract2","extract3","geoms","extractArcs","stitch","buffer","ArrayBuffer","Float64Array","Uint32Array","Math","PI","abs","atan2","cos","sin"],"mappings":"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","file":"3-58dc6-bundle.js","sourcesContent":["export default function(x) {\n  return x;\n}\n","import identity from \"./identity\";\n\nexport default function(transform) {\n  if (transform == null) return identity;\n  var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(input, i) {\n    if (!i) x0 = y0 = 0;\n    var j = 2, n = input.length, output = new Array(n);\n    output[0] = (x0 += input[0]) * kx + dx;\n    output[1] = (y0 += input[1]) * ky + dy;\n    while (j < n) output[j] = input[j], ++j;\n    return output;\n  };\n}\n","export default function(array, n) {\n  var t, j = array.length, i = j - n;\n  while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;\n}\n","import reverse from \"./reverse\";\nimport transform from \"./transform\";\n\nexport default function(topology, o) {\n  return o.type === \"GeometryCollection\"\n      ? {type: \"FeatureCollection\", features: o.geometries.map(function(o) { return feature(topology, o); })}\n      : feature(topology, o);\n}\n\nexport function feature(topology, o) {\n  var id = o.id,\n      bbox = o.bbox,\n      properties = o.properties == null ? {} : o.properties,\n      geometry = object(topology, o);\n  return id == null && bbox == null ? {type: \"Feature\", properties: properties, geometry: geometry}\n      : bbox == null ? {type: \"Feature\", id: id, properties: properties, geometry: geometry}\n      : {type: \"Feature\", id: id, bbox: bbox, properties: properties, geometry: geometry};\n}\n\nexport function object(topology, o) {\n  var transformPoint = transform(topology.transform),\n      arcs = topology.arcs;\n\n  function arc(i, points) {\n    if (points.length) points.pop();\n    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {\n      points.push(transformPoint(a[k], k));\n    }\n    if (i < 0) reverse(points, n);\n  }\n\n  function point(p) {\n    return transformPoint(p);\n  }\n\n  function line(arcs) {\n    var points = [];\n    for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);\n    if (points.length < 2) points.push(points[0]); // This should never happen per the specification.\n    return points;\n  }\n\n  function ring(arcs) {\n    var points = line(arcs);\n    while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.\n    return points;\n  }\n\n  function polygon(arcs) {\n    return arcs.map(ring);\n  }\n\n  function geometry(o) {\n    var type = o.type, coordinates;\n    switch (type) {\n      case \"GeometryCollection\": return {type: type, geometries: o.geometries.map(geometry)};\n      case \"Point\": coordinates = point(o.coordinates); break;\n      case \"MultiPoint\": coordinates = o.coordinates.map(point); break;\n      case \"LineString\": coordinates = line(o.arcs); break;\n      case \"MultiLineString\": coordinates = o.arcs.map(line); break;\n      case \"Polygon\": coordinates = polygon(o.arcs); break;\n      case \"MultiPolygon\": coordinates = o.arcs.map(polygon); break;\n      default: return null;\n    }\n    return {type: type, coordinates: coordinates};\n  }\n\n  return geometry(o);\n}\n","export default function(topology, arcs) {\n  var stitchedArcs = {},\n      fragmentByStart = {},\n      fragmentByEnd = {},\n      fragments = [],\n      emptyIndex = -1;\n\n  // Stitch empty arcs first, since they may be subsumed by other arcs.\n  arcs.forEach(function(i, j) {\n    var arc = topology.arcs[i < 0 ? ~i : i], t;\n    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {\n      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;\n    }\n  });\n\n  arcs.forEach(function(i) {\n    var e = ends(i),\n        start = e[0],\n        end = e[1],\n        f, g;\n\n    if (f = fragmentByEnd[start]) {\n      delete fragmentByEnd[f.end];\n      f.push(i);\n      f.end = end;\n      if (g = fragmentByStart[end]) {\n        delete fragmentByStart[g.start];\n        var fg = g === f ? f : f.concat(g);\n        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else if (f = fragmentByStart[end]) {\n      delete fragmentByStart[f.start];\n      f.unshift(i);\n      f.start = start;\n      if (g = fragmentByEnd[start]) {\n        delete fragmentByEnd[g.end];\n        var gf = g === f ? f : g.concat(f);\n        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else {\n      f = [i];\n      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;\n    }\n  });\n\n  function ends(i) {\n    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;\n    if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });\n    else p1 = arc[arc.length - 1];\n    return i < 0 ? [p1, p0] : [p0, p1];\n  }\n\n  function flush(fragmentByEnd, fragmentByStart) {\n    for (var k in fragmentByEnd) {\n      var f = fragmentByEnd[k];\n      delete fragmentByStart[f.start];\n      delete f.start;\n      delete f.end;\n      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });\n      fragments.push(f);\n    }\n  }\n\n  flush(fragmentByEnd, fragmentByStart);\n  flush(fragmentByStart, fragmentByEnd);\n  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });\n\n  return fragments;\n}\n","import {object} from \"./feature\";\nimport stitch from \"./stitch\";\n\nexport default function(topology) {\n  return object(topology, meshArcs.apply(this, arguments));\n}\n\nexport function meshArcs(topology, object, filter) {\n  var arcs, i, n;\n  if (arguments.length > 1) arcs = extractArcs(topology, object, filter);\n  else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;\n  return {type: \"MultiLineString\", arcs: stitch(topology, arcs)};\n}\n\nfunction extractArcs(topology, object, filter) {\n  var arcs = [],\n      geomsByArc = [],\n      geom;\n\n  function extract0(i) {\n    var j = i < 0 ? ~i : i;\n    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});\n  }\n\n  function extract1(arcs) {\n    arcs.forEach(extract0);\n  }\n\n  function extract2(arcs) {\n    arcs.forEach(extract1);\n  }\n\n  function extract3(arcs) {\n    arcs.forEach(extract2);\n  }\n\n  function geometry(o) {\n    switch (geom = o, o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(geometry); break;\n      case \"LineString\": extract1(o.arcs); break;\n      case \"MultiLineString\": case \"Polygon\": extract2(o.arcs); break;\n      case \"MultiPolygon\": extract3(o.arcs); break;\n    }\n  }\n\n  geometry(object);\n\n  geomsByArc.forEach(filter == null\n      ? function(geoms) { arcs.push(geoms[0].i); }\n      : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });\n\n  return arcs;\n}\n","export default function(a, x) {\n  var lo = 0, hi = a.length;\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (a[mid] < x) lo = mid + 1;\n    else hi = mid;\n  }\n  return lo;\n}\n","// TODO if quantized, use simpler Int32 hashing?\n\nvar buffer = new ArrayBuffer(16),\n    floats = new Float64Array(buffer),\n    uints = new Uint32Array(buffer);\n\nexport default function(point) {\n  floats[0] = point[0];\n  floats[1] = point[1];\n  var hash = uints[0] ^ uints[1];\n  hash = hash << 5 ^ hash >> 7 ^ uints[2] ^ uints[3];\n  return hash & 0x7fffffff;\n}\n","var pi = Math.PI,\n    tau = 2 * pi,\n    quarterPi = pi / 4,\n    radians = pi / 180,\n    abs = Math.abs,\n    atan2 = Math.atan2,\n    cos = Math.cos,\n    sin = Math.sin;\n\nfunction halfArea(ring, closed) {\n  var i = 0,\n      n = ring.length,\n      sum = 0,\n      point = ring[closed ? i++ : n - 1],\n      lambda0, lambda1 = point[0] * radians,\n      phi1 = (point[1] * radians) / 2 + quarterPi,\n      cosPhi0, cosPhi1 = cos(phi1),\n      sinPhi0, sinPhi1 = sin(phi1);\n\n  for (; i < n; ++i) {\n    point = ring[i];\n    lambda0 = lambda1, lambda1 = point[0] * radians;\n    phi1 = (point[1] * radians) / 2 + quarterPi;\n    cosPhi0 = cosPhi1, cosPhi1 = cos(phi1);\n    sinPhi0 = sinPhi1, sinPhi1 = sin(phi1);\n\n    // Spherical excess E for a spherical triangle with vertices: south pole,\n    // previous point, current point.  Uses a formula derived from Cagnoli’s\n    // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).\n    // See https://github.com/d3/d3-geo/blob/master/README.md#geoArea\n    var dLambda = lambda1 - lambda0,\n        sdLambda = dLambda >= 0 ? 1 : -1,\n        adLambda = sdLambda * dLambda,\n        k = sinPhi0 * sinPhi1,\n        u = cosPhi0 * cosPhi1 + k * cos(adLambda),\n        v = k * sdLambda * sin(adLambda);\n    sum += atan2(v, u);\n  }\n\n  return sum;\n}\n\nexport function sphericalRingArea(ring, interior) {\n  var sum = halfArea(ring, true);\n  if (interior) sum *= -1;\n  return (sum < 0 ? tau + sum : sum) * 2;\n}\n\nexport function sphericalTriangleArea(t) {\n  return abs(halfArea(t, false)) * 2;\n}\n","export * from \"topojson-client\";\nexport * from \"topojson-server\";\nexport * from \"topojson-simplify\";\n"],"sourceRoot":""}